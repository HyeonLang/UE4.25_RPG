# UE4.25_RPG

게임 명조를 모작한 프로젝트입니다.
명조 게임플레이의 주요 특징인 플레이어의 캐릭터 교체를 활용한 전투 시스템, 아이템 드롭과 획득, 리워드 획득, 미니맵 등의 UI, 게임참여 시스템 등을 직접 구현했습니다.

이 프로젝트에 특히 중점을 둔 것은 모듈화와 멀티플레이(서버-클라이언트의 동기화)입니다. 
게임의 설계를 하는 기획자들이 쉽게 게임을 조정할 수 있도록 기본 기능에서 디테일한 기능으로 단계별로 클래스를 분리하는것을 원칙으로 클래스를 설계했습니다.
대체적으로 중심이 되는 C++ 클래스와 그것을 상속받은 블루프린트 클래스로 하여 필요한 곳 마다 커스텀할 수 있도록 구현했습니다.


액션
 액션은 캐릭터의 스킬 등의 특정 행동을 담당하여 실행합니다.
 액션의 클래스 구조는 다음 사진과 같습니다.
 
 이 프로젝트의 캐릭터들은 일정한 형식의 액션을 가지고 있습니다. 예를 들면 플레이어 캐릭터들은 일반공격 액션 약 4~5개와 스킬 액션, 궁극기 액션을 가지고 있습니다.
 액션의 특성에 맞게 모듈화하여 블루프린트로 상속받아 액션제작을 쉽게 하도록 하였습니다. 공통된 부분은 Action 클래스에서 처리한 후 상속받아 함수들을 추가 혹은 override하여 만들 수 있도록 했습니다.
 
 액션은 객체 생성시 지정된 데이터에셋에서 데이터를 받습니다.
 액션은 플레이어 캐릭터 혹은 NPC의 ActionCompnent에서 호출된 후 CanStart()로 실행 조건 검사를 거쳐 StartAction()으로 실행됩니다.
 StartAction() 에서 몽타주 실행, Gamepaly tag 추가, 쿨타임 실행, 이동 입력 제어 등의 공통적인 역할을 합니다. 
 액션이 실행 된 후 몽타주의 Notify, 캔슬 조건에 의한 액션 캔슬에 의해 StopAction()이 실행되며 액션이 종료됩니다.
 StopAction() 에서는 StartAction()에서 설정한 부분 및 액션 실행 중 설정한 부분을 다시 원상태로 되돌립니다.
 
 멀티플레이 게임이므로 액션은 서버와 클라이언트에서 각각 실행되는 구조를 가집니다.
 서버에서 ActionComponent 호출에 의해 액션을 실행하며 RPC함수에 의해  클라이언트에서도 행해집니다. 그렇지 못한 경우를 대비하여  서버에서 액션 실행 시 Replicated RepData구조체의 RepData.bIsRunning가 변경되는 것을 활용하여 RepNotify함수에서 클라이언트 액션을 실행시킵니다.

 액션 실행 시 캐릭터들의 상태 변화 버그에 대해서 신경을 많이 썼습니다. 
 특히 StartAction() 에서 상태가 변경된 후 몽타주 끊김 등에 의해 원상태로 복구되지않아 생기는 버그가 나지 않도록 액션 실행시 동작하는 모든 몽타주에 StopAction AnimNotify를 추가함과 동시에 
 캔슬되는 액션에 대비해서 모든 몽타주 캔슬은 몽타주 캔슬 전용 함수로 동작하도록 했습니다.
 전용 함수는 StopAction을 호출한 뒤 몽타주 중단을 하는 내용입니다. 

 대쉬 점프 스프린트
  캐릭터의 Dash(), Jump(), Sprint()는 플레이어 캐릭터가 모두 가지고 있는 공통적인 액션입니다. 따라서 상속하여 몽타주 데이터만 각각 받아 액션을 실행 할 수 있도록 했습니다.

 공격액션의 특징
  공격액션들은 기본적으로 AmingComponent에서 주변의 적을 우선순위에 따라 타켓팅(없을경우 정면 기본값) 하여 방향과 위치를 변경하여 실행됩니다.
  일반적으로 방향은 타겟을 바라보도록 하며, 위치는 타겟이 멀 경우 액션이 적용되는 위치까지 가까이 이동하도록 했습니다. 
  이는 플레이어가 공격하는 난이도를 쉽게 만들도록 원작 명조와 같이 의도했습니다.

  키다운 액션에 경우 키가 Release되어 종료되는 경우가 아닌 경우(캐릭터의 교체 등의 경우)를, 액션실행 중 다른 액션으로 끊는 방법(CAction_CancelLoop를 실행시키는 방법)을 구현했습니다.
  
 일반공격
  NPC의 공격은 단일 공격으로 설정해두었습니다. 따라서 공격의 연계등은 BT에서 담당하도록 하였습니다.
  플레이어 캐릭터의 모든 공격은 기본적으로 콤보 공격을 염두하고 만들었습니다. 따라서 같은 키 입력에도 다른 액션이 실행되어야 합니다.
  Notifiy에서 타이밍에 따라 bCanCombo 변수를 설정하여 bCanCombo = true 인 경우 ActionComponent에서 다음 콤보 액션을 실행시키도록 했습니다.
  유기적인 액션 연결을 위해 액션 클래스에서 다음 콤보의 ActionName만 입력하면 그 액션이 나갈 수 있도록 구현했습니다.
  
 스킬
  스킬의 특징은 액션에 쿨타임을 부여했습니다. 쿨타임은 UObject를 상속받은 CCooldownManager 클래스 객체를 액션마다 추가하여 쿨타임을 관리하도록 했습니다.

 궁극기
  궁극기의 특징은 전용 카메라 액션이 있습니다. 이를 위해 전용 카메라 액터 객체를 추가하고 실행시 SetViewTarget으로 카메라 빙의를 변경하도록 했습니다.
  카메라는 미리 지정된 카메라 설정 커브에 따라 카메라 액션을 취한 뒤 몽타주의 AnimNotify를 받아 다시 플레이어 카메라로 빙의하도록 했습니다.
  궁극기 상태에서는 캐릭터 교체가 불가합니다.


캐릭터교체
 모작의 핵심 기능인 캐릭터 교체 기능입니다.
 PlayerController가 세 개의 캐릭터를 다뤄야 하기 때문에 default pawn class로 캐릭터를 생성하지 않고 직접 게임 실행시 GameMode를 통해 직접 캐릭터들을 스폰한 뒤 Possess하는 방식을 사용했습니 
 다. PlayerController에서 TArray 변수로 세개의 PlayerCharacter를 다룹니다.

 캐릭터가 교체 될 때마다 플레이어 카메라의 위치, 회전이 초기화 또는 변경되지 않도록 했습니다.
 이를 위해 플레이어 카메라 액터 객체를 따로 만들어 온필드 캐릭터의 위치에만 바인딩하고 캐릭터 교체에 영향을 받지 않도록 했습니다.
 
 캐릭터는 보이지 않고 조종할 수 없는 오프필드 상태, 보이며 Controller로 조종하는 온필드 상태 두가지 상태가 있습니다.

 캐릭터 교체의 방식은 일반 교체와 협주 교체 두가지가 있습니다.
 예를 들어 현재 A캐릭터가 온필드이고 B캐릭터로 교체한다고 가정해보겠습니다.
 일반 교체는 일반적인 상황에서 캐릭터를 교체하는 것이며 즉시 A캐릭터가 오프필드되고, B캐릭터가 온필드됩니다.
 협주 교체는 온필드 캐릭터가 일반공격, 스킬 액션이 실행되고있는 상태에서 교체하는 것이며 즉시 B캐릭터가 온필드 되며 A캐릭터는 실행중인 액션이 끝난 후 오프필드 됩니다.

 이 교체를 멀티플레이 환경에서 구현하기 위해 액션과 비슷한 방식을 사용하였습니다.
 조작감을 위해 로컬 클라이언트에서 PossessCharacter(), UnpossessCharacter()를 한 뒤 서버RPC함수로 서버에서 같은 코드를 실행시켰습니다. Replicate된 변수들이 Replicate Notify 함수를 실행시켜  서버에 적용된 변경점을 각 클라이언트에 전달하도록 했습니다.

 협주 교체 구현 부분은 Delegate 를 사용하여 UnpossessCharacter()의 부분을 온필드 액션이 종료 된 후의 Delegate.Broadcast()로 실행시켜 구현하였습니다.

상호작용

적

아이템
원작 명조의 드롭아이템 획득은 플레이어에게 직접 획득되는 방식입니다. 하지만 이 프로젝트에서는 다른 게임인 원신 처럼 일정 액터를 가진 드롭아이템 형식으로 구현했습니다.

UI

로그인 및 게임참여
로그인은 여타 웹 로그인방식과 유사합니다. 
게임 <--> flask 서버 <--> mysql db 구조로 http post 방식을 사용하여 유저의 데이터를 요청했습니다.

로비창에서는 요청한 유저의 데이터에서 자신이 설정한 닉네임과 로비 캐릭터가 보여지도록 했습니다.

